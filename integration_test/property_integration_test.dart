import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:naija_property_connect/data/models/property_model.dart';
import 'package:naija_property_connect/data/services/auth_service.dart';
import 'package:naija_property_connect/data/services/property_service.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../test/test_config.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Property Listing Integration Tests', () {
    late PropertyService propertyService;
    late AuthService authService;
    String? testPropertyId;

    setUpAll(() async {
      // Initialize Supabase
      await Supabase.initialize(
        url: TestConfig.supabaseUrl,
        anonKey: TestConfig.supabaseAnonKey,
      );

      propertyService = PropertyService();
      authService = AuthService();

      // Sign in as landlord to create properties
      try {
        await authService.signIn(
          email: TestConfig.testUser2Email,
          password: TestConfig.testUser2Password,
        );
      } catch (e) {
        // Create landlord user if doesn't exist
        await authService.signUp(
          email: TestConfig.testUser2Email,
          password: TestConfig.testUser2Password,
          fullName: TestConfig.testUser2FullName,
          role: TestConfig.testUser2Role,
        );
      }

      await Future.delayed(TestConfig.mediumDelay);
    });

    tearDownAll(() async {
      // Clean up: delete test property if created
      if (testPropertyId != null) {
        try {
          final supabase = Supabase.instance.client;
          await supabase.from('properties').delete().eq('id', testPropertyId!);
        } catch (e) {
          // Ignore cleanup errors
        }
      }
      await authService.signOut();
    });

    test('should fetch all properties', () async {
      final properties = await propertyService.getProperties();

      expect(properties, isA<List<PropertyModel>>());
      // Properties list might be empty, which is okay
    });

    test('should filter properties by type', () async {
      final properties = await propertyService.getProperties(type: 'Apartment');

      expect(properties, isA<List<PropertyModel>>());

      // Verify all returned properties are apartments
      for (final property in properties) {
        expect(property.type, equals('Apartment'));
      }
    });

    test('should filter properties by location', () async {
      final properties = await propertyService.getProperties(location: 'Lagos');

      expect(properties, isA<List<PropertyModel>>());

      // Verify all returned properties contain 'Lagos' in location
      for (final property in properties) {
        expect(property.location?.toLowerCase(), contains('lagos'));
      }
    });

    test('should filter properties by price range', () async {
      final minPrice = 100000.0;
      final maxPrice = 1000000.0;

      final properties = await propertyService.getProperties(
        minPrice: minPrice,
        maxPrice: maxPrice,
      );

      expect(properties, isA<List<PropertyModel>>());

      // Verify all returned properties are within price range
      for (final property in properties) {
        expect(property.price, greaterThanOrEqualTo(minPrice));
        expect(property.price, lessThanOrEqualTo(maxPrice));
      }
    });

    test('should filter properties with multiple criteria', () async {
      final properties = await propertyService.getProperties(
        type: 'Apartment',
        location: 'Lagos',
        minPrice: 200000.0,
        maxPrice: 800000.0,
      );

      expect(properties, isA<List<PropertyModel>>());

      // Verify all criteria are met
      for (final property in properties) {
        expect(property.type, equals('Apartment'));
        expect(property.location?.toLowerCase(), contains('lagos'));
        expect(property.price, greaterThanOrEqualTo(200000.0));
        expect(property.price, lessThanOrEqualTo(800000.0));
      }
    });

    test('should add a new property', () async {
      final userId = authService.currentUserId;
      expect(userId, isNotNull);

      final newProperty = PropertyModel(
        id: '', // Will be generated by database
        title: TestConfig.testPropertyTitle,
        description: TestConfig.testPropertyDescription,
        type: TestConfig.testPropertyType,
        location: TestConfig.testPropertyLocation,
        price: TestConfig.testPropertyPrice,
        images: [],
        features: [
          '${TestConfig.testPropertyBedrooms} bedrooms',
          '${TestConfig.testPropertyBathrooms} bathrooms',
        ],
        ownerId: userId!,
        createdAt: DateTime.now(),
      );

      await propertyService.addProperty(newProperty);

      // Wait for database to process
      await Future.delayed(TestConfig.mediumDelay);

      // Verify property was added by fetching it
      final properties = await propertyService.getProperties();
      final addedProperty = properties.firstWhere(
        (p) => p.title == TestConfig.testPropertyTitle,
        orElse: () => throw Exception('Property not found'),
      );

      expect(addedProperty.title, equals(TestConfig.testPropertyTitle));
      expect(
        addedProperty.description,
        equals(TestConfig.testPropertyDescription),
      );
      expect(addedProperty.type, equals(TestConfig.testPropertyType));
      expect(addedProperty.location, equals(TestConfig.testPropertyLocation));
      expect(addedProperty.price, equals(TestConfig.testPropertyPrice));

      // Save ID for cleanup
      testPropertyId = addedProperty.id;
    });

    test('should update an existing property', () async {
      // First create a property
      final userId = authService.currentUserId;
      expect(userId, isNotNull);

      final newProperty = PropertyModel(
        id: '',
        title: 'Property to Update',
        description: 'Original description',
        type: 'House',
        location: 'Abuja',
        price: 750000.0,
        images: [],
        features: ['4 bedrooms', '3 bathrooms'],
        ownerId: userId!,
        createdAt: DateTime.now(),
      );

      await propertyService.addProperty(newProperty);
      await Future.delayed(TestConfig.mediumDelay);

      // Fetch the created property
      final properties = await propertyService.getProperties();
      final createdProperty = properties.firstWhere(
        (p) => p.title == 'Property to Update',
      );

      // Update the property
      final updatedProperty = PropertyModel(
        id: createdProperty.id,
        title: 'Updated Property Title',
        description: 'Updated description',
        type: createdProperty.type,
        location: createdProperty.location,
        price: 850000.0,
        images: createdProperty.images,
        features: createdProperty.features,
        ownerId: createdProperty.ownerId,
        createdAt: createdProperty.createdAt,
      );

      await propertyService.updateProperty(updatedProperty);
      await Future.delayed(TestConfig.mediumDelay);

      // Verify update
      final updatedProperties = await propertyService.getProperties();
      final verifyProperty = updatedProperties.firstWhere(
        (p) => p.id == createdProperty.id,
      );

      expect(verifyProperty.title, equals('Updated Property Title'));
      expect(verifyProperty.description, equals('Updated description'));
      expect(verifyProperty.price, equals(850000.0));

      // Cleanup
      final supabase = Supabase.instance.client;
      await supabase.from('properties').delete().eq('id', createdProperty.id);
    });
  });
}
